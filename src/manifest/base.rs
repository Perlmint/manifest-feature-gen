use fallible_iterator::FallibleIterator;
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
};
use toml_edit::{Array, DocumentMut, Formatted, Item, Table, Value};

use super::{Dependency, DependencyHelper};
use crate::{Error, ToFeatureName};

const FEATURES_TABLE_NAME: &str = "features";
const TOML_AUTO_GENERATION_COMMENT: &str =
    concat!(" # auto-generated by ", env!("CARGO_CRATE_NAME"));

/// Cargo manifest representation for editing features.
///
/// This automatically removes generated features during loading.\
/// Generated features are identified by a comment.\
/// To work correctly, do not remove the auto-generated marker comment.
pub struct Manifest {
    path: PathBuf,
    original_features: HashMap<String, HashSet<String>>,
    document: DocumentMut,
}

impl Manifest {
    /// Load the manifest from the path specified
    pub fn new(path: PathBuf) -> Result<Self, Error> {
        let document = std::fs::read_to_string(&path)?;
        let mut document: toml_edit::DocumentMut = document.parse()?;

        let original_features = Self::collect_features(&document)?;

        let table = document.as_table_mut();
        if !table.contains_key(FEATURES_TABLE_NAME) {
            table.insert(FEATURES_TABLE_NAME, Item::Table(Table::new()));
        }

        let mut ret = Self {
            path,
            original_features,
            document,
        };

        ret.clear_generated_features()?;

        Ok(ret)
    }

    fn collect_features(document: &DocumentMut) -> Result<HashMap<String, HashSet<String>>, Error> {
        if let Some(features) = document.as_table().get(FEATURES_TABLE_NAME) {
            let features = features
                .as_table()
                .ok_or_else(|| Error::MalformedManifest("features is not a table".to_string()))?;
            fallible_iterator::convert(features.into_iter().map(
                |(feature, deps)| -> Result<_, Error> {
                    let deps = deps.as_array().ok_or_else(|| {
                        Error::MalformedManifest(format!("feature({}) is not a array", feature))
                    })?;

                    Ok((
                        feature.to_string(),
                        fallible_iterator::convert(deps.into_iter().map(|dep| {
                            dep.as_str()
                                .ok_or_else(|| {
                                    Error::MalformedManifest(format!(
                                        "feature({}) has non string item as dependency",
                                        feature
                                    ))
                                })
                                .map(|dep| dep.to_string())
                        }))
                        .collect::<HashSet<_>>()?,
                    ))
                },
            ))
            .collect()
        } else {
            Ok(Default::default())
        }
    }

    fn clear_generated_features(&mut self) -> Result<(), Error> {
        if let Some(features) = self.document.as_table_mut().get_mut(FEATURES_TABLE_NAME) {
            let features = features
                .as_table_mut()
                .ok_or_else(|| Error::MalformedManifest("features is not a table".to_string()))?;
            let feature_names =
                fallible_iterator::convert(features.iter().filter_map(|(feature, item)| {
                    if let Some(deps) = item.as_array() {
                        (deps
                            .decor()
                            .suffix()
                            .and_then(|s| s.as_str())
                            .unwrap_or_default()
                            .trim()
                            == TOML_AUTO_GENERATION_COMMENT.trim())
                        .then(|| Ok(feature.to_string()))
                    } else {
                        Some(Err(Error::MalformedManifest(format!(
                            "value of feature({}) is not a array",
                            feature
                        ))))
                    }
                }))
                .collect::<Vec<_>>()?;
            for feature in feature_names {
                features.remove(&feature);
            }
        }

        Ok(())
    }

    /// Add feature to manifest.
    pub fn add_features<T: ToFeatureName>(
        &mut self,
        features: impl Iterator<Item = T>,
        dependency_setter: impl Fn(&T, &mut DependencyHelper),
    ) -> Result<(), Error> {
        self.add_features_with_formatter_and_handler(
            features,
            dependency_setter,
            ToFeatureName::to_feature_name,
            |_, _| {},
        )
    }

    /// Add feature to manifest.
    /// This method provide extended functionality to handle features.
    pub fn add_features_with_handler<T: ToFeatureName>(
        &mut self,
        features: impl Iterator<Item = T>,
        dependency_setter: impl Fn(&T, &mut DependencyHelper),
        feature_handler: impl FnMut(&str, T),
    ) -> Result<(), Error> {
        self.add_features_with_formatter_and_handler(
            features,
            dependency_setter,
            ToFeatureName::to_feature_name,
            feature_handler,
        )
    }

    /// Add feature to manifest with custom formatter.
    pub fn add_features_with_formatter<T>(
        &mut self,
        features: impl Iterator<Item = T>,
        dependency_setter: impl Fn(&T, &mut DependencyHelper),
        feature_name_formatter: impl Fn(&T) -> String,
    ) -> Result<(), Error> {
        self.add_features_with_formatter_and_handler(
            features,
            dependency_setter,
            feature_name_formatter,
            |_, _| {},
        )
    }

    /// Add feature to manifest with custom formatter.
    /// This method provide extended functionality to handle features.
    pub fn add_features_with_formatter_and_handler<T>(
        &mut self,
        features: impl Iterator<Item = T>,
        dependency_setter: impl Fn(&T, &mut DependencyHelper),
        feature_name_formatter: impl Fn(&T) -> String,
        mut feature_handler: impl FnMut(&str, T),
    ) -> Result<(), Error> {
        let table = self.document.as_table_mut();
        let manifest_features = table.get_mut(FEATURES_TABLE_NAME).unwrap();
        let manifest_features = manifest_features.as_table_mut().unwrap();

        for feature in features {
            let feature_name = feature_name_formatter(&feature);
            let mut propagator = DependencyHelper(&feature_name, Default::default());
            let manual_dependent_feature = format!("__{}", feature_name);
            if manifest_features.contains_key(&manual_dependent_feature) {
                propagator
                    .1
                    .insert(Dependency::Simple(manual_dependent_feature));
            }
            dependency_setter(&feature, &mut propagator);
            let mut dependencies = propagator
                .1
                .into_iter()
                .map(Dependency::into_string)
                .collect::<Vec<_>>();
            dependencies.sort();
            let mut array = Array::from_iter(
                dependencies
                    .into_iter()
                    .map(|dep| Value::String(Formatted::<String>::new(dep))),
            );
            array.decor_mut().set_suffix(TOML_AUTO_GENERATION_COMMENT);
            manifest_features.insert(&feature_name, Item::Value(Value::Array(array)));

            feature_handler(&feature_name, feature);
        }

        Ok(())
    }

    fn check_is_changed(&self) -> Result<bool, Error> {
        let current_features = Self::collect_features(&self.document)?;

        Ok(current_features != self.original_features)
    }

    /// When manifest is changed, write back to the manifest file & return `Error::ManifestChanged`
    pub fn write(self) -> Result<bool, Error> {
        let changed = self.check_is_changed()?;

        std::fs::write(&self.path, self.document.to_string())?;

        Ok(changed)
    }
}
