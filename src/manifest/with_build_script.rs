use std::path::PathBuf;

use super::{DependencyHelper, Manifest};
use crate::{Error, ToFeatureName};

const RUST_AUTO_GENERATION_COMMENT: &str =
    concat!("// auto-generated by ", env!("CARGO_CRATE_NAME"));

/// Cargo manifest representation for generating features on out of build script
///
/// This will generate rust source code for build script.
pub struct ManifestWithBuildScript {
    manifest: Manifest,
    features: Vec<FeatureDefinition>,
    build_script_path: PathBuf,
}

struct FeatureDefinition {
    export_name: String,
    type_name: String,
    mutually_exclusive: bool,
    mandatory: bool,
    items: Vec<(String, String)>,
}

/// Build script export descriptor.
/// It describes how to export features to build script.
pub struct BuildScriptExportDescriptor<T> {
    /// This feature is mutually exclusive.
    /// When it is `true`, generated const has singular type.
    /// When it is `false`, generated const has `&'static []` type.
    pub mutually_exclusive: bool,
    /// This feature is mandatory.
    /// When `mutually_exclusive` is `false`, this value is ignored.
    /// When it is `true`, generated const will be wrapped with `Option` type.
    pub mandatory: bool,
    /// Name of the generated const.
    pub constant_name: String,
    /// Type name of generated const
    pub feature_type_name: String,
    /// Code generator for each feature.
    /// This function should return constant time construction code.
    pub feature_code_formatter: Box<dyn Fn(&T) -> String>,
}

impl ManifestWithBuildScript {
    /// Create new manifest with build script.
    ///
    /// # Arguments
    ///
    /// * `manifest_path` - Path to the manifest file.
    /// * `build_script_path` - Path to the build script file.
    pub fn new(manifest_path: PathBuf, build_script_path: PathBuf) -> Result<Self, Error> {
        Ok(Self {
            manifest: Manifest::new(manifest_path)?,
            build_script_path,
            features: Vec::new(),
        })
    }

    /// Add features to the manifest.
    ///
    /// # Arguments
    ///
    /// * `export` - Export descriptor for the build script.
    /// * `features` - Iterator of features to add.
    /// * `dependency_setter` - Function to set dependencies for each feature.
    pub fn add_features<T: ToFeatureName>(
        &mut self,
        export: Option<BuildScriptExportDescriptor<T>>,
        features: impl Iterator<Item = T>,
        dependency_setter: impl Fn(&T, &mut DependencyHelper<'_>),
    ) -> Result<(), Error> {
        self.add_features_with_formatter(
            export,
            features,
            dependency_setter,
            ToFeatureName::to_feature_name,
        )
    }

    /// Adds features to the manifest.
    ///
    /// # Arguments
    ///
    /// * `export` - Export descriptor for the build script.
    /// * `features` - Iterator of features to add.
    /// * `dependency_setter` - Function to set dependencies for each feature.
    /// * `feature_name_formatter` - Function to format feature names.
    pub fn add_features_with_formatter<T>(
        &mut self,
        export: Option<BuildScriptExportDescriptor<T>>,
        features: impl Iterator<Item = T>,
        dependency_setter: impl Fn(&T, &mut DependencyHelper),
        feature_name_formatter: impl Fn(&T) -> String,
    ) -> Result<(), Error> {
        let mut definition = export.map(|d| {
            (
                FeatureDefinition {
                    export_name: d.constant_name,
                    type_name: d.feature_type_name,
                    mutually_exclusive: d.mutually_exclusive,
                    mandatory: d.mandatory,
                    items: Vec::new(),
                },
                d.feature_code_formatter,
            )
        });

        self.manifest.add_features_with_formatter_and_handler(
            features,
            dependency_setter,
            feature_name_formatter,
            |feature_name, feature| {
                if let Some((definition, feature_code_formatter)) = definition.as_mut() {
                    definition
                        .items
                        .push((feature_name.to_string(), feature_code_formatter(&feature)));
                }
            },
        )?;
        if let Some(definition) = definition {
            self.features.push(definition.0);
        }

        Ok(())
    }

    /// Writes manifest file & build script to disk
    /// It returns `true` if manifest file or build script was changed
    pub fn write(self) -> Result<bool, Error> {
        use std::fmt::Write;
        let changed = self.manifest.write()?;

        let mut build_script = String::new();
        writeln!(&mut build_script, "{}", RUST_AUTO_GENERATION_COMMENT)?;
        for FeatureDefinition {
            export_name,
            type_name,
            mutually_exclusive,
            mandatory,
            items,
        } in self.features
        {
            writeln!(&mut build_script)?;
            writeln!(&mut build_script)?;

            writeln!(&mut build_script, "// Feature {export_name}")?;
            if mutually_exclusive {
                writeln!(&mut build_script, "#[cfg(not(any(")?;
                for (feature_name, _) in &items {
                    writeln!(&mut build_script, "feature = \"{feature_name}\",")?;
                }
                writeln!(&mut build_script, ")))]")?;

                if mandatory {
                    writeln!(
                        &mut build_script,
                        "std::compile_error!(\"Mandatory feature is not set.\");"
                    )?;
                    for (feature_name, code) in items {
                        writeln!(&mut build_script, "#[cfg(feature = \"{feature_name}\")]")?;
                        writeln!(
                            &mut build_script,
                            "const {export_name}: {type_name} = {code};"
                        )?;
                    }
                } else {
                    writeln!(
                        &mut build_script,
                        "const {export_name}: Option<{type_name}> = None;"
                    )?;
                    for (feature_name, code) in items {
                        writeln!(&mut build_script, "#[cfg(feature = \"{feature_name}\")]")?;
                        writeln!(
                            &mut build_script,
                            "const {export_name}: Option<{type_name}> = Some({code});"
                        )?;
                    }
                }
            } else {
                writeln!(
                    &mut build_script,
                    "const {export_name}: &[{type_name}] = &const {{["
                )?;
                for (feature_name, code) in items {
                    writeln!(
                        &mut build_script,
                        "#[cfg(feature = \"{feature_name}\")]{code},",
                    )?;
                }
                writeln!(&mut build_script, "]}};")?;
            }
        }

        let write_build_script = if self.build_script_path.exists() {
            let old_script = std::fs::read_to_string(&self.build_script_path)?;
            old_script != build_script
        } else {
            true
        };

        if write_build_script {
            std::fs::write(self.build_script_path, build_script)?;
        }

        Ok(changed || write_build_script)
    }
}
